# 外接数据源开发文档

## 1. 简介

外接数据源是一种允许用户通过JavaScript文件动态扩展系统数据源能力的机制。通过外接数据源，用户可以自定义实现特定API的解析逻辑，而无需修改系统核心代码。

主要特点：
- **灵活性**：支持从任意URL加载JavaScript数据源
- **动态性**：可在运行时添加、移除数据源
- **持久化**：外接数据源配置保存在localStorage中，下次启动自动加载
- **隔离性**：使用沙箱机制执行外部脚本，提高安全性
- **跨域支持**：内置CORS代理服务，自动处理跨域请求

## 2. 接口规范

所有外接数据源必须实现以下标准接口：

### 2.1 必要属性

| 属性名 | 类型 | 描述 |
|-------|------|------|
| `name` | String | 数据源名称，用于在界面中显示 |
| `baseUrl` | String | 数据源基础URL，用于API请求和标识 |

### 2.2 必要方法

| 方法名 | 参数 | 返回值 | 描述 |
|-------|------|-------|------|
| `searchMovies` | `keyword: String`<br>`page: Number`<br>`pageSize: Number` | `Promise<SearchResult>` | 搜索电影/资源 |
| `getMovieDetail` | `id: String` | `Promise<MovieDetail>` | 获取电影/资源详情 |

### 2.3 可选属性

| 属性名 | 类型 | 默认值 | 描述 |
|-------|------|-------|------|
| `useXml` | Boolean | false | 是否使用XML格式解析响应 |

### 2.4 数据结构

#### SearchResult 结构

```typescript
interface SearchResult {
  dataList: SearchItem[];   // 搜索结果项数组
  total: number;            // 总结果数
  pagecount: number;        // 总页数
  size: number;             // 每页条数
  current: number;          // 当前页码
}

interface SearchItem {
  vod_id: string;           // 资源唯一标识
  vod_name: string;         // 资源标题
  vod_pic?: string;         // 海报图片URL
  vod_year?: string;        // 年份
  vod_remarks?: string;     // 备注信息
  vod_area?: string;        // 地区
  type_name?: string;       // 分类
  vod_blurb?: string;       // 简短描述
}
```

#### MovieDetail 结构

```typescript
interface MovieDetail {
  vod_id: string;           // 资源唯一标识
  vod_name: string;         // 资源标题
  vod_pic?: string;         // 海报图片URL
  vod_blurb?: string;       // 简短描述
  vod_content?: string;     // 详细描述
  vod_play_url?: string;    // 播放地址（原始格式）
  vod_year?: string;        // 年份
  vod_area?: string;        // 地区
  vod_remarks?: string;     // 备注信息
  type_name?: string;       // 分类
  vod_actor?: string;       // 演员
  vod_director?: string;    // 导演
  play_list?: PlayList[];   // 解析后的播放列表
}

interface PlayList {
  source: string;           // 播放源名称
  episodes: Episode[];      // 剧集列表
}

interface Episode {
  name: string;             // 剧集名称
  url: string;              // 播放地址
}
```

## 3. 开发指南

### 3.1 基本结构

创建一个外接数据源，基本结构如下：

```javascript
// 使用CommonJS模块规范
module.exports = {
  // 必要属性
  name: "示例数据源",
  baseUrl: "https://example.com/api.php/provide/vod",
  
  // 可选属性
  useXml: false,  // 设置为true表示API返回XML格式
  
  // 必要方法：搜索电影/资源
  async searchMovies(keyword, page = 1, pageSize = 20) {
    try {
      console.log(`[示例数据源] 搜索: ${keyword}, 页码: ${page}, 每页: ${pageSize}`);
      
      // 构建API URL
      const endpoint = `?ac=detail&wd=${encodeURIComponent(keyword)}&pg=${page}`;
      const url = `${this.baseUrl}${endpoint}`;
      
      console.log('请求URL:', url);
      console.log('使用数据格式:', this.useXml ? 'XML' : 'JSON');
      
      // 发送请求
      const jsonData = await this.makeRequest(url);
      
      // 处理返回数据
      if (jsonData && jsonData.code === 1 && jsonData.list) {
        console.log('[示例数据源] API搜索结果:', jsonData);
        
        // 返回标准格式的搜索结果
        return {
          dataList: jsonData.list.map(item => ({
            vod_id: item.vod_id,
            vod_name: item.vod_name,
            vod_pic: item.vod_pic || '',
            // 其他字段...
          })),
          total: parseInt(jsonData.total) || 0,
          pagecount: parseInt(jsonData.pagecount) || 0,
          size: pageSize,
          current: page
        };
      } else {
        throw new Error(jsonData?.msg || '搜索失败');
      }
    } catch (error) {
      console.error('[示例数据源] 搜索失败:', error);
      // 返回空结果而不是抛出错误，提高用户体验
      return {
        dataList: [],
        total: 0,
        pagecount: 0,
        size: pageSize,
        current: page
      };
    }
  },
  
  // 必要方法：获取电影/资源详情
  async getMovieDetail(id) {
    try {
      console.log(`[示例数据源] 获取详情: ${id}`);
      
      // 构建API URL
      const endpoint = `?ac=detail&ids=${id}`;
      const url = `${this.baseUrl}${endpoint}`;
      
      console.log('请求URL:', url);
      console.log('使用数据格式:', this.useXml ? 'XML' : 'JSON');
      
      // 发送请求
      const jsonData = await this.makeRequest(url);
      
      if (jsonData && jsonData.code === 1 && jsonData.list && jsonData.list.length > 0) {
        const movie = jsonData.list[0];
        console.log('[示例数据源] API详情结果:', movie);
        
        // 解析播放列表
        const playList = this.parsePlayList(movie.vod_play_url);
        
        // 返回标准格式的详情结果
        return {
          vod_id: movie.vod_id,
          vod_name: movie.vod_name,
          vod_pic: movie.vod_pic || '',
          // 其他字段...
          play_list: playList
        };
      } else {
        throw new Error(jsonData?.msg || '获取详情失败');
      }
    } catch (error) {
      console.error('[示例数据源] 获取详情失败:', error);
      throw error;
    }
  }
};
```

### 3.2 开发步骤

1. **分析目标API**：确定API端点、参数和响应格式（JSON或XML）
2. **实现搜索方法**：在`searchMovies`方法中实现对API的调用和结果转换
3. **实现详情方法**：在`getMovieDetail`方法中实现获取详情的逻辑
4. **测试和调试**：使用console.log记录关键信息进行调试
5. **发布文件**：将JS文件发布到可访问的URL

### 3.3 CORS代理和网络请求

系统提供了内置的CORS代理服务，可以轻松解决跨域请求问题。推荐使用以下方式进行网络请求：

```javascript
// 辅助函数：添加CORS代理前缀
function addCorsProxy(url) {
  // 使用系统内置的CORS代理服务
  const PROXY_BASE_URL = '/proxy?url=';
  
  // 如果URL已经包含了代理前缀，则直接返回
  if (url.includes('/proxy?url=')) {
    return url;
  }
  
  // 使用encodeURIComponent编码整个URL
  const encodedUrl = encodeURIComponent(url);
  return `${PROXY_BASE_URL}${encodedUrl}`;
}

// 辅助函数：发送网络请求
async function makeRequest(url, options = {}) {
  // 添加CORS代理
  const proxyUrl = addCorsProxy(url);
  
  // 设置合适的请求头
  const headers = this.useXml 
    ? {
        'Accept': 'application/xml',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
      }
    : {
        'Accept': 'application/json',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        ...options.headers
      };
  
  const response = await fetch(proxyUrl, {
    method: 'GET',
    headers,
    ...options
  });
  
  if (!response.ok) {
    throw new Error(`HTTP错误: ${response.status}`);
  }
  
  // 根据响应类型获取数据
  const data = this.useXml ? await response.text() : await response.json();
  return this.parseResponse(data);
}
```

### 3.4 XML数据格式支持

如果API返回XML格式数据，可以使用以下方法进行处理：

#### 3.4.1 设置XML格式支持

```javascript
module.exports = {
  name: "XML数据源示例",
  baseUrl: "https://example.com/api.php/provide/vod/at/xml/",
  useXml: true,  // 重要！标记为XML格式
  
  // 其他方法...
};
```

#### 3.4.2 XML响应解析函数

```javascript
// 通用响应解析函数 - 自动识别JSON和XML
parseResponse(response) {
  if (!response) return null;
  
  try {
    // 检查是否是XML格式
    const isXmlResponse = this.useXml || 
      (typeof response === 'string' && response.trim().startsWith('<?xml'));
    
    if (isXmlResponse) {
      console.log('[数据源] 解析XML响应');
      return this.parseXMLResponse(response);
    } else {
      // 尝试解析为JSON
      console.log('[数据源] 解析JSON响应');
      if (typeof response === 'string') {
        return JSON.parse(response);
      } else {
        return response;
      }
    }
  } catch (error) {
    console.error('[数据源] 解析响应失败:', error);
    return null;
  }
},

// XML解析函数 - 将XML响应转换为标准JSON格式
parseXMLResponse(xmlString) {
  if (!xmlString) return null;
  
  try {
    // 使用DOMParser解析XML字符串
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlString, 'application/xml');
    
    // 检查是否有解析错误
    const parseError = xmlDoc.querySelector('parsererror');
    if (parseError) {
      console.error('XML解析错误:', parseError.textContent);
      return null;
    }
    
    // 获取基本信息
    const list = xmlDoc.querySelector('list');
    if (!list) return null;
    
    const page = parseInt(list.getAttribute('page') || '1');
    const pagecount = parseInt(list.getAttribute('pagecount') || '1');
    const pagesize = parseInt(list.getAttribute('pagesize') || '30');
    const recordcount = parseInt(list.getAttribute('recordcount') || '0');
    
    // 解析视频列表
    const videos = [];
    const videoElements = xmlDoc.querySelectorAll('video');
    
    videoElements.forEach(video => {
      // 提取CDATA内容的辅助函数
      const getCDataContent = (element) => {
        if (!element) return '';
        // 对于CDATA内容，需要获取文本内容
        return element.textContent || '';
      };
      
      // 提取简单元素的文本内容
      const getElementText = (parent, tagName) => {
        const element = parent.querySelector(tagName);
        if (!element) return '';
        return element.textContent || '';
      };
      
      // 构建单个视频对象
      const videoObj = {
        vod_id: getElementText(video, 'id'),
        vod_name: getCDataContent(video.querySelector('name')),
        type_name: getElementText(video, 'type'),
        vod_pic: getElementText(video, 'pic'),
        vod_lang: getElementText(video, 'lang'),
        vod_area: getElementText(video, 'area'),
        vod_year: getElementText(video, 'year'),
        vod_remarks: getCDataContent(video.querySelector('note')),
        vod_actor: getCDataContent(video.querySelector('actor')),
        vod_director: getCDataContent(video.querySelector('director')),
        vod_content: getCDataContent(video.querySelector('des')),
        vod_play_url: ''
      };
      
      // 解析播放地址
      const dlElement = video.querySelector('dl');
      if (dlElement) {
        const ddElements = dlElement.querySelectorAll('dd');
        ddElements.forEach(dd => {
          const flag = dd.getAttribute('flag');
          if (flag) {
            videoObj.vod_play_url = getCDataContent(dd);
          }
        });
      }
      
      videos.push(videoObj);
    });
    
    // 返回格式化的数据
    return {
      code: 1,
      msg: '数据列表',
      page,
      pagecount,
      limit: pagesize,
      total: recordcount,
      list: videos
    };
  } catch (error) {
    console.error('解析XML数据失败:', error);
    return null;
  }
}
```

### 3.5 播放列表解析

无论是JSON还是XML格式，资源的播放地址通常需要特殊解析：

```javascript
// 辅助方法：解析播放列表
parsePlayList(playUrl) {
  if (!playUrl) return [];
  
  try {
    // 格式通常为: "播放源1$地址1#地址2#地址3$$$播放源2$地址1#地址2"
    const sourceList = playUrl.split('$$$');
    const playList = [];
    
    sourceList.forEach(source => {
      const parts = source.split('$');
      if (parts.length >= 2) {
        const sourceName = parts[0];
        const urls = parts[1].split('#');
        
        const episodes = urls.map((url, index) => ({
          name: `第${index + 1}集`,
          url
        }));
        
        playList.push({
          source: sourceName,
          episodes
        });
      }
    });
    
    return playList;
  } catch (error) {
    console.error('解析播放列表失败:', error);
    return [];
  }
}
```

## 4. 安全注意事项

### 4.1 潜在风险

外接数据源功能涉及动态加载和执行外部JavaScript代码，存在以下风险：

- **恶意代码执行**：外部代码可能包含恶意内容
- **数据泄露**：恶意代码可能窃取浏览器中的敏感信息
- **跨站脚本攻击**：恶意代码可能发起XSS攻击
- **API滥用**：过度调用可能导致API被封禁

### 4.2 安全建议

1. **仅使用可信来源**：只加载来自可信赖的来源的外接数据源
2. **检查代码内容**：加载前检查脚本内容，确保没有明显恶意代码
3. **使用沙箱执行**：在受限环境中执行外部代码
4. **限制API访问频率**：实现请求限流，避免过度调用API
5. **启用CSP策略**：配置内容安全策略，限制外部脚本的能力

## 5. 示例

在项目的`frontend/src/extDS`目录中提供了以下示例：

- `heimuer.js`：黑木耳影视数据源示例（JSON格式）
- `wolong.js`：卧龙影视数据源示例（XML格式）
- `liangzi.js`：量子影视数据源示例（JSON格式）
- `template.js`：数据源模板，支持JSON和XML格式，可作为开发新数据源的起点

## 6. 常见问题

### 6.1 跨域问题

**问题**：请求外部API时遇到CORS错误。

**解决方案**：所有外部请求都应使用系统提供的CORS代理。在请求URL前添加`/proxy?url=`前缀并对URL进行编码：

```javascript
const proxyUrl = `/proxy?url=${encodeURIComponent(originalUrl)}`;
```

或使用文档中提供的`addCorsProxy`辅助函数。

### 6.2 数据格式问题

**问题**：API返回的数据格式与系统期望的格式不一致。

**解决方案**：在`searchMovies`和`getMovieDetail`方法中进行数据转换，确保返回符合接口规范的数据结构。

### 6.3 XML解析错误

**问题**：XML数据解析失败。

**解决方案**：
1. 确保设置了`useXml: true`
2. 使用适当的请求头：`'Accept': 'application/xml'`
3. 使用`response.text()`而非`response.json()`获取响应
4. 实现`parseXMLResponse`方法处理XML数据

## 7. 更新日志

### 2023年8月更新
- 增强CORS代理支持
- 增加XML格式数据源的完整支持
- 更新模板文件，支持自动识别JSON和XML格式
- 改进错误处理和日志记录 