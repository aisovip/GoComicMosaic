# 外挂数据源接入方案

## 1. 需求概述

为了支持更灵活的数据源接入方式，特别是对于非标准的API接口，我们需要实现一个功能，允许用户通过URL链接指定一个外部JavaScript文件（例如 `https://dm.xueximeng.com/assets/ds/heimuer.js`），系统自动获取并将其加载为一个数据源。

## 2. 技术架构

### 2.1 整体设计

我们将在现有的数据源管理系统基础上，添加对外部数据源的支持：

1. **扩展数据源管理器**：增加加载外部数据源的能力
2. **动态脚本加载**：实现远程JS文件的安全加载和执行
3. **接口适配**：确保外部数据源符合系统要求的接口
4. **持久化存储**：保存外部数据源的配置，以便系统重启后自动加载
5. **用户界面**：提供管理外部数据源的界面

### 2.2 系统架构图

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│                 │    │                 │    │                 │
│  管理界面        │◄───►  数据源管理器    │◄───►   外部JS文件    │
│ (Admin.vue)     │    │(DataSourceMgr)  │    │ (Remote JS)     │
│                 │    │                 │    │                 │
└─────────────────┘    └────────┬────────┘    └─────────────────┘
                               │
                      ┌────────▼────────┐
                      │                 │
                      │ 配置持久化存储   │
                      │(localStorage/DB)│
                      │                 │
                      └─────────────────┘
```

## 3. 实现方案

### 3.1 外部数据源接口规范

外部JS文件必须导出一个符合以下接口的对象：

```javascript
// 外部数据源必须实现的接口
const externalDataSource = {
  // 基本信息
  name: '自定义数据源名称',  // 必填
  baseUrl: 'https://example.com/api.php/provide/vod',  // 必填
  description: '数据源描述', // 可选
  useXml: false, // 可选，是否使用XML格式解析响应
  
  // 必须实现的方法
  searchMovies: async function(keyword, page = 1, pageSize = 20) {
    try {
      console.log(`[自定义数据源] 搜索: ${keyword}, 页码: ${page}, 每页: ${pageSize}`);
      
      // 构建API URL
      const endpoint = `?ac=detail&wd=${encodeURIComponent(keyword)}&pg=${page}`;
      const url = `${this.baseUrl}${endpoint}`;
      
      // 发送请求
      const jsonData = await makeRequest(url);
      
      if (jsonData && jsonData.code === 1 && jsonData.list) {
        // 返回标准格式的搜索结果
        return {
          dataList: jsonData.list.map(item => ({
            vod_id: item.vod_id,
            vod_name: item.vod_name,
            vod_pic: item.vod_pic || '',
            vod_blurb: item.vod_blurb || '',
            vod_remarks: item.vod_remarks || '',
            vod_year: item.vod_year || '',
            vod_area: item.vod_area || '',
            type_name: item.type_name || ''
          })),
          total: parseInt(jsonData.total) || 0,
          pagecount: parseInt(jsonData.pagecount) || 0,
          size: pageSize,
          current: page
        };
      } else {
        throw new Error('搜索失败');
      }
    } catch (error) {
      console.error('[自定义数据源] 搜索失败:', error);
      return {
        dataList: [],
        total: 0,
        pagecount: 0,
        size: pageSize,
        current: page
      };
    }
  },
  
  getMovieDetail: async function(id) {
    try {
      console.log(`[自定义数据源] 获取详情: ${id}`);
      
      // 构建API URL
      const endpoint = `?ac=detail&ids=${id}`;
      const url = `${this.baseUrl}${endpoint}`;
      
      // 发送请求
      const jsonData = await makeRequest(url);
      
      if (jsonData && jsonData.code === 1 && jsonData.list && jsonData.list.length > 0) {
        const movie = jsonData.list[0];
        
        // 解析播放列表
        const playList = this.parsePlayList(movie.vod_play_url);
        
        // 返回标准格式的详情结果
        return {
          vod_id: movie.vod_id,
          vod_name: movie.vod_name,
          vod_pic: movie.vod_pic || '',
          vod_blurb: movie.vod_blurb || movie.vod_content || '',
          vod_content: movie.vod_content || '',
          vod_play_url: movie.vod_play_url || '',
          vod_year: movie.vod_year || '',
          vod_area: movie.vod_area || '',
          vod_remarks: movie.vod_remarks || '',
          type_name: movie.type_name || '',
          vod_actor: movie.vod_actor || '',
          vod_director: movie.vod_director || '',
          play_list: playList
        };
      } else {
        throw new Error('获取详情失败');
      }
    } catch (error) {
      console.error('[自定义数据源] 获取详情失败:', error);
      throw error;
    }
  },
  
  // 辅助方法：解析播放列表
  parsePlayList: function(playUrl) {
    if (!playUrl) return [];
    
    try {
      // 格式通常为: "播放源1$地址1#地址2#地址3$$$播放源2$地址1#地址2"
      const sourceList = playUrl.split('$$$');
      const playList = [];
      
      sourceList.forEach(source => {
        const parts = source.split('$');
        if (parts.length >= 2) {
          const sourceName = parts[0];
          const urls = parts[1].split('#');
          
          const episodes = urls.map((url, index) => ({
            name: `第${index + 1}集`,
            url
          }));
          
          playList.push({
            source: sourceName,
            episodes
          });
        }
      });
      
      return playList;
    } catch (error) {
      console.error('解析播放列表失败:', error);
      return [];
    }
  }
};

module.exports = externalDataSource;
```

### 3.2 辅助函数实现

为了便于开发外部数据源，我们提供了以下辅助函数：

```javascript
// 辅助函数：添加CORS代理前缀
function addCorsProxy(url) {
  // 使用系统内置的CORS代理服务
  const PROXY_BASE_URL = '/proxy?url=';
  
  // 如果URL已经包含了代理前缀，则直接返回
  if (url.includes('/proxy?url=')) {
    return url;
  }
  
  // 使用encodeURIComponent编码整个URL
  const encodedUrl = encodeURIComponent(url);
  return `${PROXY_BASE_URL}${encodedUrl}`;
}

// 辅助函数：发送网络请求
async function makeRequest(url, options = {}) {
  // 添加CORS代理
  const proxyUrl = addCorsProxy(url);
  
  const response = await fetch(proxyUrl, {
    method: 'GET',
    headers: {
      'Accept': 'application/json',
      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
      ...options.headers
    },
    ...options
  });
  
  if (!response.ok) {
    throw new Error(`HTTP错误: ${response.status}`);
  }
  
  return response.json();
}

// 处理XML格式的请求
async function makeXmlRequest(url) {
  // 添加CORS代理
  const proxyUrl = addCorsProxy(url);
  
  const response = await fetch(proxyUrl, {
    method: 'GET',
    headers: {
      'Accept': 'application/xml',
      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
    }
  });
  
  if (!response.ok) {
    throw new Error(`HTTP错误: ${response.status}`);
  }
  
  const xmlText = await response.text();
  return parseXML(xmlText);
}

// XML解析助手函数
function parseXML(xmlString) {
  const parser = new DOMParser();
  const xmlDoc = parser.parseFromString(xmlString, "text/xml");
  
  // 递归将XML转为JavaScript对象
  function xmlToObj(node) {
    if (node.nodeType === Node.TEXT_NODE) {
      return node.nodeValue.trim();
    }
    
    const obj = {};
    if (node.attributes) {
      for (let i = 0; i < node.attributes.length; i++) {
        const attr = node.attributes[i];
        obj[`@${attr.nodeName}`] = attr.nodeValue;
      }
    }
    
    for (let i = 0; i < node.childNodes.length; i++) {
      const child = node.childNodes[i];
      if (child.nodeType === Node.TEXT_NODE) {
        if (child.nodeValue.trim() !== '') {
          obj._text = child.nodeValue.trim();
        }
      } else {
        const childObj = xmlToObj(child);
        if (obj[child.nodeName]) {
          if (!Array.isArray(obj[child.nodeName])) {
            obj[child.nodeName] = [obj[child.nodeName]];
          }
          obj[child.nodeName].push(childObj);
        } else {
          obj[child.nodeName] = childObj;
        }
      }
    }
    
    return obj;
  }
  
  return xmlToObj(xmlDoc.documentElement);
}
```

### 3.3 外部数据源加载器实现

创建一个专门的模块来处理外部数据源的加载：

```javascript
// externalDataSourceLoader.js

/**
 * 加载外部数据源
 * @param {string} url - 外部数据源JS文件的URL
 * @returns {Promise<Object>} - 加载的数据源对象
 */
export async function loadExternalDataSource(url) {
  try {
    // 加载外部脚本
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Failed to fetch: ${response.statusText}`);
    }
    
    const jsContent = await response.text();
    
    // 创建一个安全的执行环境
    const dataSource = await executeExternalScript(jsContent, url);
    
    // 验证数据源格式
    validateDataSource(dataSource);
    
    // 返回数据源对象
    return {
      ...dataSource,
      isExternal: true,
      sourceUrl: url,
      id: generateDataSourceId(dataSource.name, url)
    };
  } catch (error) {
    console.error(`Failed to load external data source from ${url}:`, error);
    throw error;
  }
}

/**
 * 在安全的环境中执行外部脚本
 */
async function executeExternalScript(jsContent, sourceUrl) {
  // 使用Function构造器创建一个新的作用域
  // 注意：这并不能完全隔离代码，仅提供基本的隔离
  const scriptFunction = new Function(`
    "use strict";
    // 创建模块环境
    const module = { exports: {} };
    const exports = module.exports;
    
    // 执行脚本代码
    ${jsContent}
    
    // 返回导出的模块
    return module.exports.__esModule ? module.exports.default : module.exports;
  `);
  
  // 执行脚本并获取结果
  return scriptFunction();
}

/**
 * 验证数据源是否实现了必要的接口
 */
function validateDataSource(dataSource) {
  if (!dataSource) {
    throw new Error('Invalid data source: No export found');
  }
  
  // 检查必填字段
  if (!dataSource.name) {
    throw new Error('Invalid data source: Missing name property');
  }
  
  if (!dataSource.baseUrl) {
    throw new Error('Invalid data source: Missing baseUrl property');
  }
  
  // 检查必要的方法
  if (typeof dataSource.searchMovies !== 'function') {
    throw new Error('Invalid data source: Missing searchMovies method');
  }
  
  if (typeof dataSource.getMovieDetail !== 'function') {
    throw new Error('Invalid data source: Missing getMovieDetail method');
  }
  
  return true;
}

/**
 * 生成数据源ID
 */
function generateDataSourceId(name, url) {
  // 从URL中提取文件名作为前缀
  const fileName = url.split('/').pop().replace('.js', '');
  // 组合ID: ext_{文件名}_{时间戳}
  return `ext_${fileName}_${Date.now()}`;
}
```

### 3.4 扩展数据源管理器

修改现有的 `dataSourceManager.js`，添加对外部数据源的支持：

```javascript
// 在 DataSourceManager 类中添加以下方法

/**
 * 加载外部数据源
 * @param {string} url - 数据源JS文件的URL
 * @returns {Promise<Object>} - 加载的数据源对象
 */
async loadExternalDataSource(url) {
  try {
    // 导入外部数据源加载器
    const { loadExternalDataSource } = await import('./externalDataSourceLoader');
    
    // 加载外部数据源
    const dataSource = await loadExternalDataSource(url);
    
    // 注册到数据源列表
    this.register(dataSource.id, dataSource);
    
    // 保存外部数据源配置
    this.saveExternalDataSources();
    
    console.log(`成功加载外部数据源: ${dataSource.name} (${url})`);
    return dataSource;
  } catch (error) {
    console.error(`加载外部数据源失败:`, error);
    throw error;
  }
}

/**
 * 删除外部数据源
 * @param {string} id - 数据源ID
 */
removeExternalDataSource(id) {
  if (!this.dataSources[id]) {
    throw new Error(`未找到数据源: ${id}`);
  }
  
  // 如果当前正在使用这个数据源，切换到默认数据源
  if (this.currentDataSourceId === id) {
    const availableDataSources = Object.keys(this.dataSources).filter(sid => sid !== id);
    if (availableDataSources.length > 0) {
      this.setCurrentDataSource(availableDataSources[0]);
    }
  }
  
  // 从列表中删除
  delete this.dataSources[id];
  
  // 保存外部数据源配置
  this.saveExternalDataSources();
}

/**
 * 保存外部数据源配置
 */
saveExternalDataSources() {
  try {
    // 提取所有外部数据源的URL
    const externalSources = Object.values(this.dataSources)
      .filter(ds => ds.isExternal)
      .map(ds => ({
        id: ds.id,
        name: ds.name,
        url: ds.sourceUrl
      }));
    
    // 保存到localStorage
    localStorage.setItem('externalDataSources', JSON.stringify(externalSources));
  } catch (error) {
    console.error('保存外部数据源配置失败:', error);
  }
}

/**
 * 加载保存的外部数据源
 */
async loadExternalDataSources() {
  try {
    // 从localStorage读取配置
    const savedSources = localStorage.getItem('externalDataSources');
    if (!savedSources) return;
    
    const externalSources = JSON.parse(savedSources);
    
    // 按顺序加载外部数据源
    for (const source of externalSources) {
      try {
        await this.loadExternalDataSource(source.url);
        console.log(`成功加载保存的外部数据源: ${source.name}`);
      } catch (error) {
        console.error(`加载保存的外部数据源失败: ${source.name}`, error);
      }
    }
  } catch (error) {
    console.error('加载保存的外部数据源配置失败:', error);
  }
}
```

## 4. 用户界面

### 4.1 外部数据源管理界面

在管理页面中添加外部数据源管理组件：

```vue
<!-- ExternalDataSourceManager.vue -->
<template>
  <div class="external-datasource-manager">
    <h2>外部数据源管理</h2>
    
    <!-- 添加数据源 -->
    <div class="add-source">
      <input 
        v-model="newSourceUrl" 
        placeholder="输入外部数据源JS文件URL"
        class="url-input"
      />
      <button @click="addDataSource" :disabled="isLoading">
        {{ isLoading ? '加载中...' : '添加数据源' }}
      </button>
    </div>
    
    <!-- 错误信息 -->
    <div v-if="error" class="error-message">
      {{ error }}
    </div>
    
    <!-- 数据源列表 -->
    <div class="source-list">
      <h3>已加载的外部数据源</h3>
      <div v-if="externalSources.length === 0" class="no-sources">
        暂无外部数据源
      </div>
      <div v-else class="source-items">
        <div v-for="source in externalSources" :key="source.id" class="source-item">
          <div class="source-info">
            <div class="source-name">{{ source.name }}</div>
            <div class="source-url">{{ source.sourceUrl }}</div>
          </div>
          <div class="source-actions">
            <button @click="removeDataSource(source.id)" class="remove-btn">
              删除
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      newSourceUrl: '',
      isLoading: false,
      error: null
    };
  },
  
  computed: {
    externalSources() {
      // 获取所有外部数据源
      return Object.values(this.$dataSourceManager.dataSources)
        .filter(ds => ds.isExternal);
    }
  },
  
  methods: {
    async addDataSource() {
      if (!this.newSourceUrl) {
        this.error = '请输入数据源URL';
        return;
      }
      
      this.isLoading = true;
      this.error = null;
      
      try {
        await this.$dataSourceManager.loadExternalDataSource(this.newSourceUrl);
        this.newSourceUrl = '';
        this.$toast.success('数据源添加成功');
      } catch (error) {
        this.error = `数据源加载失败: ${error.message}`;
        this.$toast.error(this.error);
      } finally {
        this.isLoading = false;
      }
    },
    
    async removeDataSource(id) {
      try {
        await this.$dataSourceManager.removeExternalDataSource(id);
        this.$toast.success('数据源已删除');
      } catch (error) {
        this.error = `删除数据源失败: ${error.message}`;
        this.$toast.error(this.error);
      }
    }
  }
};
</script>
```

### 4.2 在App启动时加载外部数据源

修改 `main.js` 或应用启动逻辑：

```javascript
// 在应用初始化时加载保存的外部数据源
async function initApp() {
  // 初始化数据源管理器
  const dataSourceManager = new DataSourceManager();
  app.config.globalProperties.$dataSourceManager = dataSourceManager;
  
  // 加载保存的外部数据源
  await dataSourceManager.loadExternalDataSources();
  
  // 挂载应用
  app.mount('#app');
}

// 启动应用
initApp();
```

## 5. 安全考虑

外部数据源功能涉及动态加载和执行外部JavaScript代码，存在安全风险。我们采取以下措施：

1. **沙箱执行**：使用隔离的作用域执行外部代码
2. **验证接口**：确保外部数据源符合预期的接口规范
3. **用户提示**：提醒用户只加载来自可信赖的来源的代码
4. **CORS代理**：所有外部请求通过系统的CORS代理，减少隐私泄露风险
5. **限制API**：外部数据源只能访问有限的API，无法直接访问系统关键功能

## 6. 示例数据源

我们提供了几个示例数据源，可供用户参考：

1. **黑木耳影视数据源**：[heimuer.js](/extDS/heimuer.js)
2. **卧龙影视数据源**：[wolong.js](/extDS/wolong.js)
3. **量子影视数据源**：[liangzi.js](/extDS/liangzi.js)
4. **数据源模板**：[template.js](/extDS/template.js)

## 7. 故障排除

### 7.1 常见问题

1. **数据源加载失败**
   - 确保URL正确可访问
   - 检查JS文件内容是否符合接口规范
   - 查看浏览器控制台错误信息

2. **搜索/详情请求失败**
   - 检查数据源实现的searchMovies/getMovieDetail方法
   - 确认API接口可正常访问
   - 查看CORS代理是否正常工作

3. **数据显示异常**
   - 检查返回的数据结构是否符合系统要求
   - 检查数据格式转换逻辑

### 7.2 调试方法

1. 在JS文件中添加`console.log`语句输出关键信息
2. 使用浏览器开发者工具查看网络请求和响应
3. 检查返回的数据结构是否符合系统要求 