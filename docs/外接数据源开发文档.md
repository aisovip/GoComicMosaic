# 外接数据源开发文档

## 1. 概述

本文档详细说明如何为东漫网站开发外接数据源，以便接入第三方视频内容。外接数据源是一个符合特定接口规范的JavaScript模块，可以动态加载到系统中，提供视频搜索和详情获取功能。

## 2. 外接数据源基本结构

一个标准的外接数据源模块需要包含以下基本结构：

```javascript
module.exports = {
  // 必要属性
  name: "数据源名称",
  baseUrl: "https://api.example.com",
  
  // 请求头配置
  headers: {
    // 默认请求头
  },
  
  // 必要方法
  async searchMovies(keyword, page, pageSize) {
    // 实现搜索功能
  },
  
  async getMovieDetail(id) {
    // 实现获取详情功能
  },
  
  // 可选辅助方法
  // ...
};
```

## 3. 详细实现示例 (以蓝莓短剧为例)

以下是`lanmei.js`的详细实现，展示了一个完整的外接数据源：

### 3.1 基本信息与请求头

```javascript
module.exports = {
  // 必要属性
  name: "蓝莓短剧",
  baseUrl: "https://app.whjzjx.cn",
     
  // 请求头
  headers: {
    "Connection": "keep-alive",
    "Content-Type": "application/x-www-form-urlencoded",
    "user-agent": "okhttp/4.10.0",
    "user_agent": "Mozilla/5.0 (Linux; Android 9; ASUS_I003DD Build/PI; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/68.0.3440.70 Mobile Safari/537.36",
    "Host": "app.whjzjx.cn",
    "Accept-Encoding": "gzip"
  },
  
  // token缓存
  token: null,
  tokenExpireTime: 0,
  
  // 其他方法...
};
```

### 3.2 认证与请求处理

许多API需要认证，以下是一个获取并使用token的示例：

```javascript
/**
 * 获取API访问Token
 */
async getToken() {
  // 如果token有效期内，直接返回
  const currentTime = Math.floor(Date.now() / 1000);
  if (this.token && currentTime < this.tokenExpireTime) {
    return this.token;
  }
  
  // 否则重新获取
  try {
    const tkurl = 'https://app.whjzjx.cn/v1/account/login';
    const body = "device=20caaae96b3443174bf4ebdbdcc253776";
    
    // 登录请求直接使用原始URL，无需代理
    const response = await fetch(tkurl, {
      method: 'POST',
      headers: this.headers,
      body: body
    });
    
    if (!response.ok) {
      throw new Error(`HTTP错误: ${response.status}`);
    }
    
    const jsonData = await response.json();
    console.log(`获取token成功: ${JSON.stringify(jsonData)}`);
    if (jsonData.code === 0 || jsonData.code === "ok" || jsonData.status === 0) {
      this.token = jsonData.data.token;
      // 设置token过期时间为1小时
      this.tokenExpireTime = currentTime + 3600;
      return this.token;
    }
    
    console.log(`获取token失败: ${JSON.stringify(jsonData)}`);
    return null;
  } catch (e) {
    console.error(`获取token异常: ${e.message}`);
    return null;
  }
},

/**
 * 带token的网络请求
 */
async fetchWithToken(url, options = {}) {
  const token = await this.getToken();
  if (!token) {
    console.log("无法获取token");
    return null;
  }
  
  const headers = {...this.headers, "authorization": token};
  if (options.headers) {
    Object.assign(headers, options.headers);
  }
  
  try {
    // 只有需要自定义头信息时才使用代理，普通API请求直接使用原始URL
    const needsProxy = options.forceProxy === true;
    const requestUrl = needsProxy ? this.addCorsProxy(url, headers) : url;
    
    const requestOptions = {
      method: options.method || 'GET',
      headers: headers
    };
    
    if (options.body) {
      requestOptions.body = options.body;
    }
    
    const response = await fetch(requestUrl, requestOptions);
    
    if (!response.ok) {
      throw new Error(`HTTP错误: ${response.status}`);
    }
    
    return await response.json();
  } catch (e) {
    console.error(`请求失败: ${url}, 错误: ${e.message}`);
    return null;
  }
}
```

### 3.3 实现搜索方法

`searchMovies`是外接数据源必须实现的核心方法之一，用于搜索视频内容：

```javascript
/**
 * 必要方法：搜索电影/资源
 * 这是外接数据源必须实现的方法
 */
async searchMovies(keyword, page = 1, pageSize = 20) {
  console.log(`[蓝莓短剧] 搜索: ${keyword}, 页码: ${page}, 每页: ${pageSize}`);
  
  try {
    // 构建搜索请求
    const url = `${this.baseUrl}/v2/search`;
    const body = `text=${encodeURIComponent(keyword)}`;
    
    const jsonData = await this.fetchWithToken(url, {
      method: 'POST',
      body: body
    });
    
    if (!jsonData) {
      console.log('搜索请求失败或返回为空');
      return { dataList: [], total: 0, pagecount: 0, size: pageSize, current: page };
    }
    
    // 检查API返回状态
    if (!(jsonData.code === 0 || jsonData.code === "ok" || jsonData.status === 0)) {
      console.log(`搜索数据失败: ${JSON.stringify(jsonData)}`);
      return { dataList: [], total: 0, pagecount: 0, size: pageSize, current: page };
    }
    
    // 解析搜索结果
    const searchData = jsonData.data?.search_data || [];
    console.log(`[蓝莓短剧] 搜索结果数量: ${searchData.length}`);
    
    // 转换为标准格式
    const videos = searchData.map(item => {
      return {
        vod_id: item.id,
        vod_name: item.title,
        vod_pic: item.cover_url,
        vod_remarks: `${item.score_str || ''}|${item.total || ''}集`,
        vod_year: '',
        vod_area: '',
        type_name: ''
      };
    });
    
    // 返回标准格式的搜索结果
    return {
      dataList: videos,
      total: videos.length || 0,
      pagecount: 1, // 假设只有一页
      size: pageSize,
      current: parseInt(page)
    };
  } catch (e) {
    console.error(`搜索内容异常: ${e.message}`);
    return { dataList: [], total: 0, pagecount: 0, size: pageSize, current: page };
  }
}
```

### 3.4 实现详情获取方法

`getMovieDetail`是另一个必须实现的核心方法，用于获取视频详情：

```javascript
/**
 * 必要方法：获取电影/资源详情
 * 这是外接数据源必须实现的第二个核心方法
 */
async getMovieDetail(id) {
  console.log(`[蓝莓短剧] 获取详情: ${id}`);
  
  try {
    // 构建详情页请求URL
    const url = `${this.baseUrl}/v2/theater_parent/detail?theater_parent_id=${id}`;
    const jsonData = await this.fetchWithToken(url);
    
    if (!jsonData) {
      throw new Error("获取详情数据失败");
    }
    
    // 检查API返回状态
    if (!(jsonData.code === 0 || jsonData.code === "ok" || jsonData.status === 0)) {
      console.error(`获取详情数据失败: ${JSON.stringify(jsonData)}`);
      throw new Error(`获取详情数据失败: ${jsonData.msg || '未知错误'}`);
    }
    
    // 解析详情数据
    const data = jsonData.data || {};
    const title = data.title || '';
    const cover = data.cover_url || '';
    const total = data.total || '';
    const introduction = data.introduction || '';
    
    // 提取剧集列表
    const theaters = data.theaters || [];
    const playList = [];
    
    // 构建正确格式的播放列表字符串 - 格式: "1$url1#2$url2#3$url3"
    let playUrl = '';
    // 设置播放所需的headers，特别是Referer头
    const playHeaders = {
      "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36",
      "Referer": "http://qcapp.xingya.com.cn/"
    };
    
    if (theaters.length > 0) {
      playUrl = theaters.map((theater, index) => {
        const episodeNum = theater.num || (index + 1);
        let videoUrl = theater.son_video_url || '';
        
        // 检查视频URL的来源，判断是否需要添加Referer头
        const needsReferer = videoUrl && (
          videoUrl.includes('xingya.com.cn') || 
          videoUrl.includes('.m3u8') || 
          videoUrl.includes('.mp4')
        );
        
        // 对于MP4视频，我们直接提供URL和headers，而不使用代理
        if (needsReferer) {
          // 保留原始URL
          return `${episodeNum}$${videoUrl}`;
        }
        
        return `${episodeNum}$${videoUrl}`;
      }).join('#');
      
      // 构建剧集列表 (保留原来的逻辑用于兼容)
      const episodes = theaters.map((theater, index) => {
        const epName = `第${theater.num || (index+1)}集`;
        let epUrl = theater.son_video_url || '';
        
        // 检查视频URL的来源，判断是否需要添加Referer头
        const needsReferer = epUrl && (
          epUrl.includes('xingya.com.cn') || 
          epUrl.includes('.m3u8') || 
          epUrl.includes('.mp4')
        );
        
        // 对于MP4视频，我们直接提供URL和headers，而不使用代理
        if (needsReferer) {
          // 保留原始URL
          return {
            name: epName,
            url: epUrl
          };
        }
        
        // 只有需要自定义Referer头的视频URL才使用代理
        if (needsReferer && !epUrl.includes('/proxy?url=')) {
          epUrl = this.addCorsProxy(epUrl, playHeaders);
        }
        
        return {
          name: epName,
          url: epUrl
        };
      });
      
      // 添加播放源
      if (episodes.length > 0) {
        playList.push({
          source: "蓝莓短剧",
          episodes: episodes
        });
      }
    }
    
    console.log(`[蓝莓短剧] 解析到 ${theaters.length} 集剧集`);
    // 构建VOD数据
    return {
      vod_id: id,
      vod_name: title,
      vod_pic: cover,
      vod_remarks: `${total}集`,
      vod_content: introduction,
      vod_year: '',
      vod_area: '',
      vod_actor: '',
      vod_director: '',
      type_name: '蓝莓短剧',
      vod_play_from: "蓝莓短剧",
      vod_play_url: playUrl, // 使用构建好的播放URL字符串
      // 添加必要的头信息，这将被前端使用
      vod_play_header: JSON.stringify({
        "Referer": "http://qcapp.xingya.com.cn/", 
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36"
      }),
      playList: playList // 保留旧格式，兼容现有代码
    };
  } catch (e) {
    console.error(`获取详情内容异常: ${e.message}`);
    throw e; // 重新抛出异常，以便外部处理
  }
}
```

### 3.5 跨域代理处理

处理跨域请求是外接数据源的重要功能，以下是一个实现示例：

```javascript
/**
 * 添加CORS代理前缀
 * @param {string} url - 要代理的URL
 * @param {Object} [headers] - 需要传递的请求头
 * @returns {string} 代理后的URL
 */
addCorsProxy(url, headers) {
  // 如果URL已经包含了代理前缀，则直接返回
  if (url.includes('/proxy?url=')) {
    return url;
  }
  
  // 如果URL为空，直接返回
  if (!url) {
    return '';
  }
  
  // 始终使用代理，不再进行条件判断
  // 使用系统内置的CORS代理服务
  let PROXY_BASE_URL = '/proxy?url=';
  
  // 将headers转换为JSON字符串并进行编码
  if (headers && Object.keys(headers).length > 0) {
    // 确保headers是一个包含所有必要信息的干净对象
    const cleanHeaders = {};
    
    // 只保留重要的头信息
    if (headers.Referer || headers.referer) {
      cleanHeaders.Referer = headers.Referer || headers.referer;
    }
    
    if (headers["User-Agent"]) {
      cleanHeaders["User-Agent"] = headers["User-Agent"];
    }
    
    // 转换为JSON字符串并编码
    const encodedHeaders = encodeURIComponent(JSON.stringify(cleanHeaders));
    PROXY_BASE_URL = `/proxy?headers=${encodedHeaders}&url=`;
  }
  
  // 使用encodeURIComponent编码整个URL
  const encodedUrl = encodeURIComponent(url);
  return `${PROXY_BASE_URL}${encodedUrl}`;
}
```

### 3.6 API请求与视频URL的区别处理

在外接数据源中，需要区分API请求和视频URL的处理方式：

```javascript
/**
 * 带token的网络请求
 * 注意：此方法主要用于API请求，不使用代理
 * 视频URL应该通过addCorsProxy方法单独处理
 */
async fetchWithToken(url, options = {}) {
  const token = await this.getToken();
  if (!token) {
    console.log("无法获取token");
    return null;
  }
  
  const headers = {...this.headers, "authorization": token};
  if (options.headers) {
    Object.assign(headers, options.headers);
  }
  
  try {
    // API请求通常不需要代理，直接使用原始URL
    // 只有在options.forceProxy=true时才使用代理（用于特殊情况）
    const needsProxy = options.forceProxy === true;
    const requestUrl = needsProxy ? this.addCorsProxy(url, headers) : url;
    
    const requestOptions = {
      method: options.method || 'GET',
      headers: headers
    };
    
    if (options.body) {
      requestOptions.body = options.body;
    }
    
    const response = await fetch(requestUrl, requestOptions);
    
    if (!response.ok) {
      throw new Error(`HTTP错误: ${response.status}`);
    }
    
    return await response.json();
  } catch (e) {
    console.error(`请求失败: ${url}, 错误: ${e.message}`);
    return null;
  }
}
```

## 4. 标准数据格式

### 4.1 搜索结果格式

`searchMovies`方法必须返回以下格式的数据：

```javascript
{
  dataList: [
    {
      vod_id: "123",           // 视频ID，字符串或数字
      vod_name: "视频标题",     // 视频标题
      vod_pic: "封面图URL",     // 封面图URL
      vod_remarks: "更新至第8集", // 备注信息，如更新状态
      vod_year: "2023",        // 年份(可选)
      vod_area: "大陆",        // 地区(可选)
      type_name: "动漫"        // 类型(可选)
    },
    // 更多结果...
  ],
  total: 100,      // 总结果数
  pagecount: 5,    // 总页数
  size: 20,        // 每页大小
  current: 1       // 当前页码
}
```

### 4.2 视频详情格式

`getMovieDetail`方法必须返回以下格式的数据：

```javascript
{
  vod_id: "123",                 // 视频ID
  vod_name: "视频标题",           // 视频标题
  vod_pic: "封面图URL",           // 封面图URL
  vod_remarks: "更新至第8集",      // 备注信息
  vod_content: "视频简介内容...",   // 简介
  vod_year: "2023",              // 年份(可选)
  vod_area: "大陆",              // 地区(可选)
  vod_actor: "演员1,演员2",       // 演员(可选)
  vod_director: "导演名",         // 导演(可选)
  type_name: "动漫",             // 类型(可选)
  vod_play_from: "播放源名称",     // 播放源名称
  vod_play_url: "1$http://example.com/ep1.m3u8#2$http://example.com/ep2.m3u8", // 播放地址，格式为"集数$URL"，多集用#分隔
  vod_play_header: '{"Referer":"http://example.com"}' // 播放所需的请求头，JSON字符串格式
}
```

### 4.3 播放URL格式

`vod_play_url`字段使用特定格式来表示剧集列表：

```
1$http://example.com/ep1.m3u8#2$http://example.com/ep2.m3u8#3$http://example.com/ep3.m3u8
```

格式说明：
- 每个剧集用`#`分隔
- 每个剧集内部用`$`分隔剧集标题和URL
- 剧集标题通常是集数，但也可以是自定义文本

## 5. 视频播放与请求头处理

### 5.1 设置自定义请求头

许多视频源需要特定的请求头（如Referer）才能正常播放。在`getMovieDetail`方法中，通过`vod_play_header`字段提供这些头信息：

```javascript
// 添加必要的头信息，这将被前端使用
vod_play_header: JSON.stringify({
  "Referer": "http://qcapp.xingya.com.cn/", 
  "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36"
})
```

### 5.2 视频URL处理的一致性原则

**重要**：在同一个数据源中，所有视频URL必须采用相同的处理方式，要么全部使用代理，要么全部不使用代理。混合使用会导致不可预测的播放问题。

```javascript
// 正确的做法：统一处理所有视频URL
if (theaters.length > 0) {
  // 统一处理：所有视频URL都通过代理处理
  playUrl = theaters.map((theater, index) => {
    const episodeNum = theater.num || (index + 1);
    const videoUrl = theater.son_video_url || '';
    
    // 对所有URL都使用代理，确保一致性
    const proxyUrl = this.addCorsProxy(videoUrl, playHeaders);
    return `${episodeNum}$${proxyUrl}`;
  }).join('#');
  
  // 构建剧集列表 (保留原来的逻辑用于兼容)
  const episodes = theaters.map((theater, index) => {
    const epName = `第${theater.num || (index+1)}集`;
    const epUrl = theater.son_video_url || '';
    
    // 对所有URL都使用代理，确保一致性
    const proxyUrl = this.addCorsProxy(epUrl, playHeaders);
    
    return {
      name: epName,
      url: proxyUrl
    };
  });
}
```

### 5.3 处理不同类型的视频URL

不同类型的视频URL（如HLS/m3u8、MP4等）可能需要不同的处理方式，但在同一个数据源中，应该保持一致的代理策略：

1. **需要代理的情况**：
   - 视频源需要特定的Referer或User-Agent
   - 视频URL返回302重定向
   - 视频源服务器没有设置正确的CORS头

2. **可能不需要代理的情况**：
   - 视频源已经配置了正确的CORS头
   - 视频源不需要特殊的请求头
   - 视频源与网站同源

无论选择哪种方式，都应该在整个数据源中保持一致。

### 5.4 常见问题及解决方案

#### 5.4.1 302重定向问题

某些视频URL会返回302状态码进行重定向，这在直接请求时可能会导致跨域问题。使用代理可以解决这个问题：

```javascript
// 设置代理选项，允许重定向
const options = {
  headers: customHeaders,
  redirect: 'follow'
};

// 使用代理处理重定向
const proxyUrl = this.addCorsProxy(videoUrl, customHeaders);
```

#### 5.4.2 CORS错误

如果遇到类似以下的错误：

```
Access to video at 'http://example.com/video.mp4' from origin 'http://localhost:3000' 
has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present 
on the requested resource.
```

应该始终使用代理处理所有视频URL：

```javascript
// 在getMovieDetail方法中
// 对所有视频URL都使用代理
const proxyUrl = this.addCorsProxy(videoUrl, playHeaders);
```

## 6. 错误处理与日志

良好的错误处理和日志记录对于调试和维护外接数据源至关重要：

```javascript
try {
  // 尝试执行代码
} catch (e) {
  // 详细记录错误信息
  console.error(`[蓝莓短剧] 操作失败: ${e.message}`);
  console.error(`详细错误:`, e);
  
  // 返回标准错误格式或重新抛出异常
  throw new Error(`获取数据失败: ${e.message}`);
}
```

## 7. 测试与调试

### 7.1 本地测试

1. 创建外接数据源JS文件
2. 在浏览器控制台中测试基本功能：
   ```javascript
   const dataSource = require('./your-data-source.js');
   dataSource.searchMovies('测试关键词').then(console.log);
   ```

### 7.2 常见问题排查

1. **跨域问题**：检查是否需要使用代理，确保`addCorsProxy`方法正确实现
2. **认证失败**：验证token获取逻辑，检查请求头是否正确
3. **解析错误**：确保返回的数据格式符合标准规范
4. **播放失败**：检查视频URL是否有效，是否提供了必要的请求头

## 8. 最佳实践

### 8.1 代码质量

1. **模块化**：将功能分解为小型、可测试的函数
2. **注释**：为复杂逻辑添加详细注释
3. **错误处理**：捕获并适当处理所有可能的异常

### 8.2 性能优化

1. **缓存**：缓存token和其他不常变化的数据
2. **请求合并**：尽可能减少API请求次数
3. **延迟加载**：只在需要时加载数据

### 8.3 安全性

1. **敏感信息保护**：不要硬编码API密钥和凭证
2. **输入验证**：验证所有用户输入和API响应
3. **错误信息处理**：不要向用户暴露敏感的错误详情

## 9. 提交与发布

### 9.1 代码提交

1. 确保代码符合项目规范
2. 进行全面测试，验证所有功能
3. 添加详细文档，说明使用方法和注意事项

### 9.2 发布流程

1. 将JS文件上传到可访问的URL
2. 在系统中注册外接数据源
3. 测试集成后的功能

## 10. 参考资源

1. **API文档**：参考目标API的官方文档
2. **示例代码**：查看其他外接数据源的实现
3. **调试工具**：使用浏览器开发者工具和网络分析工具 